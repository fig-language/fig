use crate::LexicalError;
use crate::ast::*;
use nyx_lexer::{Token, FloatLiteral, IntegerLiteral};

grammar;

// ============================================================================
// Main Entry Point
// ============================================================================

/// Main entry point for parsing an entire source file
pub SourceFile: SourceFile = {
    <items: SourceFileItem*> => SourceFile::new(items)
};

/// Top-level items in a source file (same as NamespaceItem but at file level)
SourceFileItem: NamespaceItem = {
    <namespace_decl: Namespace> => NamespaceItem::Namespace(namespace_decl),
    <enum_decl: Enum> => NamespaceItem::Enum(enum_decl),
    <union_decl: Union> => NamespaceItem::Union(union_decl),
    <struct_decl: Struct> => NamespaceItem::Struct(struct_decl),
    <interface_decl: Interface> => NamespaceItem::Interface(interface_decl),
    <function_decl: Function> => NamespaceItem::Function(function_decl),
    // Simple type alias (single line) - needs NEWLINE after it
    "type" <name: "ident"> <generic_params: GenericParameterList?> "=" <aliased_type: Type> "NEWLINE" => {
        NamespaceItem::TypeAlias(TypeAlias::new(
            name,
            generic_params.unwrap_or_default(),
            aliased_type,
            Vec::new()
        ))
    },
    // Type alias with where clause (multi-line) - already ends with DEDENT
    "type" <name: "ident"> <generic_params: GenericParameterList?>
    "NEWLINE" "INDENT"
    <where_clause: WhereClause>
    "NEWLINE"
    "=" <aliased_type: Type>
    "DEDENT" => {
        NamespaceItem::TypeAlias(TypeAlias::new(
            name,
            generic_params.unwrap_or_default(),
            aliased_type,
            where_clause
        ))
    },
};

/// Main entry point for expression parsing with precedence levels
/// Level 0 = highest precedence (primary expressions)
/// Level 8 = lowest precedence (logical OR)
pub Expression: Expression = {
    // Level 0: Primary expressions (highest precedence)
    #[precedence(level="0")]
    Unary,
    
    // Level 1: Multiplication, Division, Modulo
    #[precedence(level="1")] #[assoc(side="left")]
    <lhs:Expression> "*" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::Multiply, Box::new(rhs)
    )),
    <lhs:Expression> "/" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::Divide, Box::new(rhs)
    )),
    <lhs:Expression> "%" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::Modulo, Box::new(rhs)
    )),
    
    // Level 2: Addition and Subtraction
    #[precedence(level="2")] #[assoc(side="left")]
    <lhs:Expression> "+" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::Add, Box::new(rhs)
    )),
    <lhs:Expression> "-" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::Subtract, Box::new(rhs)
    )),
    
    // Level 3: Bit shifts
    #[precedence(level="3")] #[assoc(side="left")]
    <lhs:Expression> "<<" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::ShiftLeft, Box::new(rhs)
    )),
    <lhs:Expression> ">>" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::ShiftRight, Box::new(rhs)
    )),
    
    // Level 4: Comparison operators
    #[precedence(level="4")] #[assoc(side="left")]
    <lhs:Expression> "<" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::LessThan, Box::new(rhs)
    )),
    <lhs:Expression> ">" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::GreaterThan, Box::new(rhs)
    )),
    <lhs:Expression> "<=" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::LessThanOrEqual, Box::new(rhs)
    )),
    <lhs:Expression> ">=" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::GreaterThanOrEqual, Box::new(rhs)
    )),
    
    // Level 5: Equality operators
    #[precedence(level="5")] #[assoc(side="left")]
    <lhs:Expression> "==" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::Equal, Box::new(rhs)
    )),
    <lhs:Expression> "!=" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::NotEqual, Box::new(rhs)
    )),
    
    // Level 6: Bitwise AND
    #[precedence(level="6")] #[assoc(side="left")]
    <lhs:Expression> "&" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::BitwiseAnd, Box::new(rhs)
    )),
    
    // Level 7: Bitwise XOR
    #[precedence(level="7")] #[assoc(side="left")]
    <lhs:Expression> "^" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::BitwiseXor, Box::new(rhs)
    )),
    
    // Level 8: Bitwise OR
    #[precedence(level="8")] #[assoc(side="left")]
    <lhs:Expression> "|" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::BitwiseOr, Box::new(rhs)
    )),
    
    // Level 9: Logical AND
    #[precedence(level="9")] #[assoc(side="left")]
    <lhs:Expression> "&&" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::LogicalAnd, Box::new(rhs)
    )),
    
    // Level 10: Logical OR (lowest precedence)
    #[precedence(level="10")] #[assoc(side="left")]
    <lhs:Expression> "||" <rhs:Expression> => Expression::BinaryOp(BinaryOpExpr::new(
        Box::new(lhs), BinaryOperator::LogicalOr, Box::new(rhs)
    )),
};

// ============================================================================
// Unary Expressions and Primary Expressions
// ============================================================================

/// Unary operators have higher precedence than any binary operator
/// They are applied before the expression enters the precedence hierarchy
Unary: Expression = {
    "!" <operand:Unary> => Expression::UnaryOp(UnaryOpExpr::new(
        UnaryOperator::LogicalNot, Box::new(operand)
    )),
    "~" <operand:Unary> => Expression::UnaryOp(UnaryOpExpr::new(
        UnaryOperator::BitwiseNot, Box::new(operand)
    )),
    "-" <operand:Unary> => Expression::UnaryOp(UnaryOpExpr::new(
        UnaryOperator::Negate, Box::new(operand)
    )),
    "+" <operand:Unary> => Expression::UnaryOp(UnaryOpExpr::new(
        UnaryOperator::Plus, Box::new(operand)
    )),
    "&" <operand:Unary> => Expression::UnaryOp(UnaryOpExpr::new(
        UnaryOperator::AddressOf, Box::new(operand)
    )),
    "*" <operand:Unary> => Expression::UnaryOp(UnaryOpExpr::new(
        UnaryOperator::Dereference, Box::new(operand)
    )),
    Atom,
};

// Atomic expressions - literals and identifiers
Atom: Expression = {
    IntegerLiteral,
    FloatLiteral,
    BooleanLiteral,
    CharLiteral,
    StringLiteral,
    NullLiteral,
    Identifier,
    ArrayLiteral,
    Parenthesized,
};

Parenthesized: Expression = {
    "(" <expr:Expression> ")" => Expression::Parenthesized(Box::new(expr)),
}

// ============================================================================
// Literal Expressions
// ============================================================================

IntegerLiteral: Expression = {
    <lit:"int"> => Expression::IntegerLiteral(lit),
};

FloatLiteral: Expression = {
    <lit:"float"> => Expression::FloatLiteral(lit),
};

BooleanLiteral: Expression = {
    "true" => Expression::BooleanLiteral(true),
    "false" => Expression::BooleanLiteral(false),
};

CharLiteral: Expression = {
    <lit: "char"> => {
        // The lexer returns the full character literal with quotes, e.g., "'a'"
        // The AST node expects the content *with* quotes for now.
        Expression::CharLiteral(lit)
    },
};

StringLiteral: Expression = {
    <lit: "string"> => {
        // The lexer returns the full string literal with quotes, e.g., "\"hello\""
        // The AST node expects the content *with* quotes for now.
        Expression::StringLiteral(lit)
    },
};

NullLiteral: Expression = {
    "null" => Expression::Null,
};

Identifier: Expression = {
    <id: "ident"> => Expression::Identifier(id),
};

ArrayLiteral: Expression = {
    "[" <elements:Comma<Expression>> "]" => {
        Expression::ArrayLiteral(ArrayLiteralExpr::new(elements))
    },
};

// ============================================================================
// Generic Parsing
// ============================================================================
pub GenericParameterList: Vec<GenericParameter> = {
    "[" <params:Comma<GenericParameter>> "]" => params,
};

GenericParameter: GenericParameter = {
    BoundedTypeParameter,
    TypeParameter,
    ConstParameter,
};

ConstParameter: GenericParameter = {
    "const" <name: "ident"> ":" <ty: Type> => GenericParameter::Const {
        name,
        ty,
    },
};

TypeParameter: GenericParameter = {
    <name: "ident"> => GenericParameter::Type { name, bounds: Vec::new() },
};

BoundedTypeParameter: GenericParameter = {
    <name: "ident"> ":" <bounds: TypeBounds> => GenericParameter::Type { name, bounds },
};

TypeBounds: Vec<Type> = {
    <mut bounds:(<Type> "+")*> <e:Type?> => match e {
        None => bounds,
        Some(e) => {
            bounds.push(e);
            bounds
        }
    }
}

pub GenericArgumentList: Vec<Type> = {
    "[" <args:Comma<Type>> "]" => args,
};

// ============================================================================
// Type Parsing
// ============================================================================

/// Main type parser - parses any type
pub Type: Type = {
    PointerType,
};

/// Pointer types: *raw or *T (recursively handles nested pointers like **T)
PointerType: Type = {
    <nullability: "?"?>
    "*"
    <mutability: "mut"?>
    <element_type: PointerElementType>
    => {
        match element_type {
            Some(boxed_type) => Type::Pointer {
                element_type: boxed_type,
                nullable: nullability.is_some(),
                mutable: mutability.is_some(),
            },
            None => Type::Pointer {
                element_type: Box::new(Type::U8), // *raw - placeholder, should be handled differently
                nullable: nullability.is_some(),
                mutable: mutability.is_some(),
            }
        }
    },
    ArrayType,
};

PointerElementType: Option<Box<Type>> = {
    <element_type:PointerType> => Some(Box::new(element_type)),
    "raw" => None
}

ArrayType: Type = {
    "["  <element_type:ArrayType> ";" <size:ArraySize> "]" => Type::Array{ 
        element_type: Box::new(element_type), 
        size: Some(size) 
    },
    "[" <element_type:ArrayType> "]" => Type::Array{ 
        element_type: Box::new(element_type), 
        size: None 
    },
    PrimitiveType,
    NamedType,
}

/// Helper rule to parse array size as usize
ArraySize: usize = {
    <lit:"int"> => {
        // Extract the integer value and convert to usize
        lit.as_usize().unwrap_or(0)
    },
};

NamedType: Type = {
    <name: "ident"> <generic_args: GenericArgumentList> => Type::Named{ name, generic_args },
    <name: "ident"> => Type::Named{ name, generic_args: vec![] },
};

/// Primitive types
PrimitiveType: Type = {
    "u8" => Type::U8,
    "u16" => Type::U16,
    "u32" => Type::U32,
    "u64" => Type::U64,
    "usize" => Type::USize,
    "i8" => Type::I8,
    "i16" => Type::I16,
    "i32" => Type::I32,
    "i64" => Type::I64,
    "isize" => Type::ISize,
    "f32" => Type::F32,
    "f64" => Type::F64,
    "bool" => Type::Bool,
    "ok" => Type::Ok,
    "Self" => Type::SelfType,
};


// ============================================================================
// Clause Parsing
// ============================================================================

WhereClause: Vec<GenericParameter> = {
    "where" "NEWLINE" "INDENT" <Newline<BoundedTypeParameter>> "DEDENT" => <>,
};

RequiresClause: Vec<Type> = {
    "requires" "NEWLINE" "INDENT" <Newline<Type>> "DEDENT" => <>,
};

ExtendsClause: Vec<Type> = {
    "extends" "NEWLINE" "INDENT" <Newline<Type>> "DEDENT" => <>,
};

// ============================================================================
// Type Alias Parsing
// ============================================================================

pub TypeAlias: TypeAlias = {
    "type" <name: "ident"> <generic_params: GenericParameterList?> "=" <aliased_type: Type>
    // <where_clause: TypeAliasClause?>
    => {
        TypeAlias::new(
            name,
            generic_params.unwrap_or_default(),
            aliased_type,
            // where_clause.unwrap_or_default()
            Vec::new()
        )
    },
    "type" <name: "ident"> <generic_params: GenericParameterList?>
    "NEWLINE" "INDENT"
    <where_clause: WhereClause>
    "=" <aliased_type: Type>
    "DEDENT"
    => {
        TypeAlias::new(
            name,
            generic_params.unwrap_or_default(),
            aliased_type,
            where_clause
        )
    },
};

// ============================================================================
// Enum Parsing
// ============================================================================

pub Enum: Enum = {
    "enum"
    <representation: EnumRepr?>
    <name: "ident">
    <generic_params: GenericParameterList?>
    "NEWLINE"
    "INDENT"
    <requires_clause: RequiresClause?>
    <where_clause: WhereClause?>
    <variants: EachNewlinePlus<EnumVariant>>
    "DEDENT"
    => {
        Enum::new(
            name,
            representation,
            generic_params.unwrap_or_default(),
            requires_clause.unwrap_or_default(),
            where_clause.unwrap_or_default(),
            variants
        )
    },
};

EnumRepr: Type = {
    "[" <repr_type: Type> "]" => repr_type,
};

EnumVariant: EnumVariant = {
    <name: "ident"> => EnumVariant::new(name, None),
    <name: "ident"> "=" <value: Expression> => EnumVariant::new(name, Some(value)),
};

// ============================================================================
// Union Parsing
// ============================================================================

pub Union: Union = {
    "union"
    <name: "ident">
    <generic_params: GenericParameterList?>
    "NEWLINE"
    "INDENT"
    <requires_clause: RequiresClause?>
    <where_clause: WhereClause?> 
    <variants: EachNewlinePlus<UnionVariant>>
    "DEDENT"
    => {
        Union::new(
            name,
            generic_params.unwrap_or_default(),
            requires_clause.unwrap_or_default(),
            where_clause.unwrap_or_default(),
            variants
        )
    },
};

UnionVariant: UnionVariant = {
    <name: "ident"> ":" <ty: Type> => UnionVariant::new(name, ty),
}

// ============================================================================
// Struct Parsing
// ============================================================================

pub Struct: Struct = {
    "struct"
    <name: "ident">
    <generic_params: GenericParameterList?>
    "NEWLINE"
    "INDENT"
    <requires_clause: RequiresClause?>
    <where_clause: WhereClause?>
    <fields: EachNewlinePlus<StructField>>
    "DEDENT"
    => {
        Struct::new(
            name,
            generic_params.unwrap_or_default(),
            requires_clause.unwrap_or_default(),
            where_clause.unwrap_or_default(),
            fields
        )
    },
};

StructField: StructField = {
    <name: "ident"> ":" <ty: Type> => StructField::new(name, ty),
};

// ============================================================================
// Function Parsing
// ============================================================================

pub Function: Function = {
    <signature: FunctionSignature>
    <body: Block> "DEDENT" => {
        Function::new(
            signature,
            body,
        )
    },
};

FunctionSignature: FunctionSignature = {
    "func" <name: "ident"> <generic_params: GenericParameterList?>
    "(" <params: Comma<FunctionParameter>> ")"
    <return_type: ("->" <Type>)?>
    "NEWLINE"
    "INDENT"
    <where_clause: WhereClause?>
    => {
        FunctionSignature::new(
            name,
            generic_params.unwrap_or_default(),
            params,
            return_type,
            where_clause.unwrap_or_default(),
        )
    },
};

FunctionParameter: FunctionParameter = {
    <name: "ident"> ":" <ty: Type> => FunctionParameter::new(name, ty),
};

Block: Block = {
    <statements: Newline<Statement>> => Block::new(statements),
};

Statement: Statement = {
    "pass" => Statement::Pass,
};

// ============================================================================
// Interface Parsing
// ============================================================================

pub Interface: Interface = {
    "interface" <name: "ident"> <generic_params: GenericParameterList?>
    "NEWLINE"
    "INDENT"
    <extends_clause: ExtendsClause?>
    <where_clause: WhereClause?>
    <methods: EachNewlinePlus<InterfaceMethodSignature>>
    "DEDENT"
    => {
        Interface::new(
            name,
            generic_params.unwrap_or_default(),
            extends_clause.unwrap_or_default(),
            where_clause.unwrap_or_default(),
            methods
        )
    },
};

InterfaceMethodSignature: FunctionSignature = {
    "func" <name: "ident"> <generic_params: GenericParameterList?>
    "(" <params: Comma<FunctionParameter>> ")"
    <return_type: ("->" <Type>)?>
    => {
        FunctionSignature::new(
            name,
            generic_params.unwrap_or_default(),
            params,
            return_type,
            Vec::new(),  // No where clause for interface methods
        )
    },
};

// ============================================================================
// Namespace Parsing
// ============================================================================

pub Namespace: Namespace = {
    "namespace" <name: "ident">
    "NEWLINE"
    "INDENT"
    <items: NamespaceItem*>
    "DEDENT"
    => Namespace::new(name, items)
};

NamespaceItem: NamespaceItem = {
    <namespace_decl: Namespace> => NamespaceItem::Namespace(namespace_decl),
    <enum_decl: Enum> => NamespaceItem::Enum(enum_decl),
    <union_decl: Union> => NamespaceItem::Union(union_decl),
    <struct_decl: Struct> => NamespaceItem::Struct(struct_decl),
    <interface_decl: Interface> => NamespaceItem::Interface(interface_decl),
    <function_decl: Function> => NamespaceItem::Function(function_decl),
    // Simple type alias (single line) - needs NEWLINE after it
    "type" <name: "ident"> <generic_params: GenericParameterList?> "=" <aliased_type: Type> "NEWLINE" => {
        NamespaceItem::TypeAlias(TypeAlias::new(
            name,
            generic_params.unwrap_or_default(),
            aliased_type,
            Vec::new()
        ))
    },
    // Type alias with where clause (multi-line) - already ends with DEDENT
    "type" <name: "ident"> <generic_params: GenericParameterList?>
    "NEWLINE" "INDENT"
    <where_clause: WhereClause>
    "NEWLINE"
    "=" <aliased_type: Type>
    "DEDENT" => {
        NamespaceItem::TypeAlias(TypeAlias::new(
            name,
            generic_params.unwrap_or_default(),
            aliased_type,
            where_clause
        ))
    },
};

// ============================================================================
// Helper Rules
// ============================================================================

/// Parse a list of items each of which ends in a newline, even the last one
EachNewline<T>: Vec<T> = {
    (<T> "NEWLINE")*
};

/// Parse a non-empty list of items each of which ends in a newline
EachNewlinePlus<T>: Vec<T> = {
    (<T> "NEWLINE")+
};

/// Parse a newline-separated list of items
Newline<T>: Vec<T> = {
    <mut v:(<T> "NEWLINE")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

/// Parse a plus-separated list of items  
Plus<T>: Vec<T> = {
    <mut v:(<T> "+")*> <e:T> => {
        v.push(e);
        v
    }
};

/// Parse a comma-separated list of items (with optional trailing comma)
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        // Indentation tokens
        "INDENT" => Token::Indent,
        "DEDENT" => Token::Dedent,
        "NEWLINE" => Token::Newline,
        
        // Keywords
        "func" => Token::Func,
        "let" => Token::Let,
        "mut" => Token::Mut,
        "const" => Token::Const,
        "type" => Token::Type,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "union" => Token::Union,
        "interface" => Token::Interface,
        "ext" => Token::Ext,
        "impl" => Token::Impl,
        "true" => Token::True,
        "false" => Token::False,
        "ok" => Token::OkLiteral,
        "null" => Token::Null,
        "raw" => Token::Raw,
        "super" => Token::Super,
        "self" => Token::SelfLower,
        "Self" => Token::SelfKeyword,
        "if" => Token::If,
        "else" => Token::Else,
        "elif" => Token::Elif,
        "for" => Token::For,
        "while" => Token::While,
        "break" => Token::Break,
        "continue" => Token::Continue,
        "match" => Token::Match,
        "return" => Token::Return,
        "mutable" => Token::Mutable,
        "in" => Token::In,
        "where" => Token::Where,
        "requires" => Token::Requires,
        "extends" => Token::Extends,
        "namespace" => Token::Namespace,
        "pass" => Token::Pass,
        "block" => Token::Block,
        "using" => Token::Using,
        "extern" => Token::Extern,
        "packed" => Token::Packed,
        "public" => Token::Public,
        "export" => Token::Export,
        "private" => Token::Private,
        "as" => Token::As,
        "sizeof" => Token::Sizeof,
        "alignof" => Token::Alignof,
        "offsetof" => Token::Offsetof,
        "std" => Token::Std,
        "core" => Token::Core,
        "alloc" => Token::Alloc,

        // Primitive Types
        "u8" => Token::U8,
        "u16" => Token::U16,
        "u32" => Token::U32,
        "u64" => Token::U64,
        "usize" => Token::USize,
        "isize" => Token::ISize,
        "i8" => Token::I8,
        "i16" => Token::I16,
        "i32" => Token::I32,
        "i64" => Token::I64,
        "f32" => Token::F32,
        "f64" => Token::F64,
        "bool" => Token::Bool,

        // Operators
        "?" => Token::Question,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "==" => Token::EqEq,
        "!=" => Token::Ne,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "&&" => Token::AndAnd,
        "||" => Token::OrOr,
        "!" => Token::Bang,
        "&" => Token::And,
        "|" => Token::Or,
        "^" => Token::Caret,
        "~" => Token::Tilde,
        "<<" => Token::Shl,
        ">>" => Token::Shr,
        "=" => Token::Eq,
        "+=" => Token::PlusEq,
        "-=" => Token::MinusEq,
        "*=" => Token::StarEq,
        "/=" => Token::SlashEq,
        "%=" => Token::PercentEq,
        "&=" => Token::AndEq,
        "|=" => Token::OrEq,
        "^=" => Token::CaretEq,
        "<<=" => Token::ShlEq,
        ">>=" => Token::ShrEq,
        "->" => Token::Arrow,
        "=>" => Token::FatArrow,

        // Delimiters and Punctuation
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "." => Token::Dot,

        // Special
        "_" => Token::Underscore,

        // Identifiers and Literals
        "ident" => Token::Ident(<String>),
        "float" => Token::FloatLiteral(<FloatLiteral>),
        "int" => Token::IntegerLiteral(<IntegerLiteral>),
        "string" => Token::StringLiteral(<String>),
        "char" => Token::CharLiteral(<String>),

        // Metadata
        "#" => Token::Hash,
    }
}
