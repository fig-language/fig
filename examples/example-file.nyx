fn main[T, U, V](x: i32, y: i32)
    let x: u64 = 5
    const PI: f64 = 3.14
    let y = 10
    let x: Array[*i32] = 10
    let z: *u32 = 345
    mut z = "Jello?"
    let x: *raw = 389
    let msg: string = "Hello world!"
    let special = $"Hello {23}!"
    io.println(msg)

fn add(a: i32, b: i32) -> i32
    let something = a + (b / 10) == 10
    $"Result is {a.add(b)::C}"

extern fn! malloc(size: usize) -> *mut u8
extern fn! free(ptr: *mut u8)
extern fn! memcpy(dest: *mut u8, src: *u8, n: usize) -> *mut u8

fn Vector2::add(a: i32) -> i32
    let x = 10

fn! Vector2.scale(factor: f64) -> Self
    self.x *= factor
    self.y *= factor

fn some_string[T]() -> String
    where
        T: Display
        U: Display + Ord + Clone + Hash
    $"This is a string with type {T.display()} and {U.display()}"

fn nop() -> ok
    pass

let x = 10

type Integer = i32
type DoubleRaw = *mut(*mut u8)
type Array[T] = SomeOther[T]
type Vector2::Alpine = i32

enum[u8] Dog
    requires
        Display
        Debug
    BULLFOG = 0
    POODLE = 10
    BEAGLE = 20

enum[u8] Dog::Color
    BLACK = 0
    BROWN
    WHITE = 2

union std::Either[U, V]
    requires
        Display
        Debug
    Left: U
    Right: V

struct Vector[T]
    arr: []T
    len: usize

packed struct Bits
    a: u8
    b: u16
    c: u32

interface Drawable[T]
    extends
        Display
        Debug
    fn draw(self: Self) -> ok
    fn resize(self: Self, width: T, height: T) -> ok

interface Iterator[T]
    fn next(self: Self) -> Option[T]

const HELLO_THERE = true

namespace Hello
    pass

let x = 10
