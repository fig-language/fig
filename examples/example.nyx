
type Array[T] = []T
type string = Array[u8]

struct Vector2[T]
    requires
        Display
    where
        T: Numeric
    x: T
    y: T

fn Vector2::new(x: T, y: T) -> Vector2[T]:
    Vector2(x, y)

fn Vector2::unit() -> Vector2[T]:
    Vector2:
        x: T::unit()
        y: T::unit()

fn Vector2::zero() -> Vector2[T]:
    Vector2:
        x: T::zero()
        y: T::zero()

fn Vector2::display(self) -> String:
    $"({self.x}, {self.y})"

interface Display[T]
    where
        T: Into[String]
    fn display() -> T

interface Numeric[T]
    extends
        Add,
        Sub,
        Mul,
        Div,
        Neg,
        Display
    where
        T: Sized
    fn add(self: T, other: T) -> T
    fn sub(self: T, other: T) -> T
    fn mul(self: T, other: T) -> T
    fn div(self: T, other: T) -> T
    fn neg(self: T) -> T

enum Direction:
    Up
    Down
    Left
    Right

union Either[T, U]:
    a: T
    b: U

fn reversed(name: String) -> String:
    name.reverse()

interface Add[T]:
    fn add(self: T, other: T) -> T

fn print(value: String) -> ok ! CustomError:
    std::print(value)

fn increment(value: i32) -> i32:
    let result =
        let incremented = value + 1
        incremented
    result

fn add[T](a: T, b: T) -> T
    where
        T: Add[T]:
    let x = 1

struct Matrix[T, U, V, W, X, Y, Z]:
    requires
        Add,
        Sub,
        Mul,
        Display,
        Clone,
        Iterator,
        From[T],
        Into[T],
        Serialize[W]
    where
        T: Numeric + Signed
        U: Add
        V: Display
        W: Signed
        X: Hash
        Y: Eq
        Z: Ord
    rows: i32
    cols: i32
    data: [][]T

// Thus function demonstrates the use of an anonymous union type as a 
// return type, which can be one of several types depending on the conditions
fn could() -> i32 | u8 | SomeError:
    if some_condition:
      42
    else if some_other_condition:
      255u8
    else:
      SomeError:
          reason: "An error occurred"
          timestamp: std::time::now()

fn consume_could() -> ok ! SomeError:
    let result = could()
    match result:
        i32 any_name => std::print($"Got an integer: {result}")
        u8 any_other_name => std::print($"Got a byte: {result}")
        SomeError an_error_name => std::print($"Error: {result.reason} at {result.timestamp}")
