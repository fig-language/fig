interface Math
    func add(self: Self, other: Self) -> Self
    func sub(self: Self, other: Self) -> Self

interface AddTo[T]
    func add::[Scale](self: Self, other: T, scale: Scale) -> Self

struct Vector2
    x: f64
    y: f64

func Vector2.add(other: Vector2) -> Vector2
    self.x += other.x
    self.y += other.y
    self

func Vector2.sub(other: Vector2) -> Vector2
    self.x -= other.x
    self.y -= other.y
    self


func[T] ::*T::add_to::[Scale](other: i32, scale: Scale) -> *T
    pass


// These functions belong to the global namespace and so
// it means *T will NOT satisfy the Math interface because
// these functions are not methods of *T, they are just free
// functions that take *T as parameters.
func add::[T](self: *T, other: *T) -> *T
    pass

func sub::[T](self: *T, other: *T) -> *T
    pass


// Each individual function below defines a whole class of
// methods, each with a different type T. So the first add
// function defines the method *T.add for every type T, and
// the second add function defines the method *T.sub for every
// type T. This means that *T will satisfy the Math interface
// for all T.
func[T] ::*T::add(other: *T) -> *T
    pass

func[T] ::*T::sub(other: *T) -> *T
    pass

// Undecided
func[T] ::*T::add(self: *T, other: *T) -> *T
    pass

func[T] ::*T::sub(self: *T, other: *T) -> *T
    pass

// Here we have two sets of generic parameters, T and U.
// T here means 'for all types T' at the time of function
// definition. So all slices of any type T will contain a
// method called something::[U]. As apposed to T, U is
// a type parameter that will be specified at the time of
// the method call.
func[T] ::[]T::something::[U](self: []T) -> ok
    pass

// This is the same as the previous function but uses the
// dot syntax for the self parameter. The self paramater
// is then available implicitly in the function body
func[T] ::[]T.something::[U]() -> ok
    pass

struct Array[T]
    data: []T
    len: usize

func something::Array[T]::insert(value: T) -> ok
    pass

func Array[i32]::cool_insert(value: i32) -> ok
    pass
