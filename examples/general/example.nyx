
type Slice[T] = [T]
type String = Array[u8]

struct Vector2[T]
    requires
        Display
    where
        T: Numeric
    x: T
    y: T

func Vector2::new(x: T, y: T) -> Vector2[T]
    // Vector2(x, y)
    pass

func Vector2::unit() -> Vector2[T]
    // Vector2:
    //    x: T::unit()
    //    y: T::unit()
    pass

func Vector2::zero() -> Vector2[T]
    //Vector2:
    //    x: T::zero()
    //    y: T::zero()
    pass

func Vector2::display(self) -> String
    $"({self.x}, {self.y})"
  
interface Display[T]
    where
        T: Into[String]
    func display() -> T

interface Numeric[T]
    extends
        Add
        Sub
        Mul
        Div
        Neg
        Display
    where
        T: Sized
    func add(self, other: T) -> T
    func sub(self, other: T) -> T
    func mul(self, other: T) -> T
    func div(self, other: T) -> T
    func neg(self) -> T

enum Direction
    UP
    DOWN
    LEFT
    RIGHT

union Either[T, U]
    a: T
    b: U

func reversed(name: String) -> String
    name.reverse()

interface Add[T]
    func add(self: T, other: T) -> T

func print(value: String)
    std::print(value)

// func increment(value: i32) -> i32
//    let result =
//        let incremented = value + 1
//        incremented
//    result

func add::[T](a: T, b: T) -> T
    where
        T: Add[T]
    let x = 1

struct math::Matrix[T, U, V, W, X, Y, Z]
    requires
        Add,
        Sub,
        Mul,
        Display,
        Clone,
        Iterator,
        From[T],
        Into[T],
        Serialize[W]
    where
        T: Numeric + Signed
        U: Add
        V: Display
        W: Signed
        X: Hash
        Y: Eq
        Z: Ord
    rows: i32
    cols: i32
    data: [][]T

// Thus function demonstrates the use of an anonymous union type as a 
// return type, which can be one of several types depending on the conditions
func could() -> i32 | u8 | SomeError:
    if some_condition:
      42
    else if some_other_condition:
      255u8
    else:
      SomeError:
          reason: "An error occurred"
          timestamp: std::time::now()

func consume_could() -> ok ! SomeError:
    let result = could()
    match result:
        i32 any_name => std::print($"Got an integer: {result}")
        u8 any_other_name => std::print($"Got a byte: {result}")
        SomeError an_error_name => std::print($"Error: {result.reason} at {result.timestamp}")
